module Test_newParser
   use funit
   use fy_Nodes
   use fy_EscapedTextStream
   use fy_newParser
   implicit none

contains

   @test
   subroutine test_single_scalar()
      type(newParser) :: p
      class(AbstractNode), allocatable :: node
      character(:), allocatable :: scalar

      p = newParser()
      node = p%load(EscapedTextStream("--- a\n..."))
      scalar = node

#ifdef __GFORTRAN__
      @assertEqual("a", scalar)
#else
      @assert_that(scalar, is("a"))
#endif

   end subroutine test_single_scalar

   @test
   subroutine test_single_flow_sequence()
      type(newParser) :: p
      class(AbstractNode), allocatable :: node
      logical :: flag

      p = newParser()
      node = p%load(EscapedTextStream("---\n [true, false, true]\n..."))

      flag = node%of(1)
      @assert_that(flag, is(true()))


      flag = node%of(2)
      @assert_that(flag, is(false()))

      flag = node%of(3)
      @assert_that(flag, is(true()))
   end subroutine test_single_flow_sequence

   @test
   subroutine test_single_flow_mapping()
      type(newParser) :: p
      class(AbstractNode), allocatable :: node
      logical :: flag

      p = newParser()
      node = p%load(EscapedTextStream("---\n {a: true, b: false}\n..."))
      call node%get(flag, "a")
      @assert_that(flag, is(equal_to(.true.)))

      flag = node%of("b")
      @assert_that(flag, is(equal_to(.false.)))

   end subroutine test_single_flow_mapping


   @test
   subroutine test_single_block_sequence()
      type(newParser) :: p
      class(AbstractNode), allocatable :: node
      logical :: flag

      p = newParser()
      node =p%load(EscapedTextStream("---\n - true \n - false \n - true \n..."))

      @assert_that(int(node%size()), is(3))
      
      call node%get(flag, 1)
      @assert_that(flag, is(.true.))
      call node%get(flag, 2)
      @assert_that(flag, is(.false.))
      call node%get(flag, 3)
      @assert_that(flag, is(.true.))

   end subroutine test_single_block_sequence

   @test
   subroutine test_nested_block_sequence()
      type(newParser) :: p
      class(AbstractNode), target, allocatable :: node
      class(AbstractNode), pointer :: sub

      integer :: i, n

      p = newParser()
      node = p%load(EscapedTextStream("---\n - \n    - 1 \n    - 2 \n - \n    - 3 \n    - 4 \n..."))
      !                                0123 0123 012345678 012345678 0123 012345678 012345678 012

      sub => node%at(1)
      call sub%get(n, 1)
      @assert_that(n, is(1))
      call sub%get(n, 2)
      @assert_that(n, is(2))

      sub => node%at(2)
      call sub%get(n, 1)
      @assert_that(n, is(3))
      call sub%get(n, 2)
      @assert_that(n, is(4))

      ! check diving all at once
      call node%get(n, 2, 1)
      @assert_that(n, is(3))
      call node%get(n, 1, 2)
      @assert_that(n, is(2))

end subroutine test_nested_block_sequence

   @test
   subroutine test_nested_block_mapping_sequence()
      type(newParser) :: p
      class(AbstractNode), target, allocatable :: node
      class(AbstractNode), pointer :: sub
      integer :: n

      p = newParser()
      node = p%load(EscapedTextStream("---\n cat: \n    - 1 \n    - 2 \n dog: \n    - 3 \n    - 4 \n..."))
      !                                0123 0123456 012345678 012345678 0123567 012345678 012345678 012

      sub => node%of('cat')
      call sub%get(n, 1)
      @assert_that(n, is(1))
      call sub%get(n, 2)
      @assert_that(n, is(2))


      sub => node%of('dog')
      call sub%get(n, 1)
      @assert_that(n, is(3))
      call sub%get(n, 2)
      @assert_that(n, is(4))

   end subroutine test_nested_block_mapping_sequence

   @test
   subroutine test_nested_mapping_block_flow()
      type(newParser) :: p
      class(AbstractNode), target, allocatable :: node
      class(AbstractNode), pointer :: sub

      integer :: v1, v2

      p = newParser()
      node = p%load(EscapedTextStream("---\n mapping: { v1: 7, v2: 8 } \n..."))


      sub => node%at('mapping')

      call sub%get(v1, 'v1')
      @assert_that(v1, is(equal_to(7)))

      call sub%get(v2, 'v2')
      @assert_that(v2, is(equal_to(8)))

   end subroutine test_nested_mapping_block_flow

   @test
   subroutine test_pflogger_reproducer()
      type(newParser) :: p
      class(AbstractNode), allocatable :: node

      p = newParser()
      node = p%load(EscapedTextStream("format: --- \n"))

   end subroutine test_pflogger_reproducer


   @test
   subroutine test_pflogger_reproducer2()
      type(newParser) :: p
      class(AbstractNode), target, allocatable :: node

      p = newParser()
      node = p%load(EscapedTextStream( &
           & " B: {a: '---' , b: hello}\n"))

   end subroutine test_pflogger_reproducer2




   @test
   subroutine test_simple_anchor()
      type(newParser) :: p
!!$      class(AbstractNode), target, allocatable :: node
      class(AbstractNode), pointer :: node
      class(AbstractNode), allocatable :: sub

      integer :: i_a, i_b

      p = newParser()
      allocate(node, source=p%load(EscapedTextStream( &
           & "---\n" // &
           & " A: &anchor \n" // &
           & "    i: 1 \n" // &
           & " B: *anchor \n" // &
           & "...")))

      call node%get(i_a, 'A', 'i')
      @assert_that(i_a, is(equal_to(1)))
      
      call node%get(i_b, 'B', 'i')
      @assert_that(i_b, is(equal_to(1)))

   end subroutine test_simple_anchor

   ! Reproducer for issue #13
   @test
   subroutine test_quoted_integer()
      type(newParser) :: p
      class(AbstractNode), allocatable :: node

      character(:), allocatable :: s

      p = newParser()
      node = p%load(EscapedTextStream(' key1: "2004" \n'))
      call node%get(s,"key1")

#ifdef __GFORTRAN__
      @assertEqual("2004", s)
#else
      @assert_that(s, is(equal_to("2004")))
#endif

   end subroutine test_quoted_integer


   @test
   subroutine test_pflogger_reproducer3
      type(newParser) :: p
      class(AbstractNode), allocatable :: node
      integer :: unit

      p = newParser()

      node = p%load(EscapedTextStream( &
           & "A: \n" // &
           & "  class: StreamHandler \n" // &
           & "  unit: -129\n" // &
           & "  level: INFO"))

      call node%get(unit, "A", "unit")
      @assert_that(unit, is(-129))

   end subroutine test_pflogger_reproducer3


   @test
   subroutine test_nested_hard_1()
      type(newParser) :: p
      class(AbstractNode), target, allocatable :: node
      class(AbstractNode), pointer :: sub
      integer :: n

      p = newParser()
      node = p%load(EscapedTextStream("---\n cat: [1 2] \n dog: [3, 4, [5, [6, 7], 8]] \n ..."))

   end subroutine test_nested_hard_1


end module Test_NewParser

