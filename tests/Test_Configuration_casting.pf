! Node types

! Instrinsic scalars
! - logical
! - integer
! - real
! - character(:), allocatable
!
! Intrinsic arrays
! - ArrayWrap(logical(:))
! - ArrayWrap(integer(:))
! - ArrayWrap(real(:))
! - ArrayWrap(character(:))
!
! Generic gFTL containers
! - UnlimitedVector
! - StringUnlimitedMap
! - IntegerUnlimitedMap
!
! TBD? - Specific gFTL containers
! - Vectors
!   - LogicalVector
!   - IntegerVector
!   - RealVector
!   - StringVector
! - Maps
!   - StringLogicalMap
!   - StringIntegerMap
!   - StringRealMap
!   - StringStringMap
!   - IntegerLogicalMap
!   - IntegerIntegerMap
!   - IntegerRealMap
!   - IntegerStringMap




module Test_Configuration_casting
  use funit
  use yafyaml
  use fy_String
  use gFTL_UnlimitedVector
  use gFTL_StringUnlimitedMap
  use, intrinsic :: iso_fortran_env, only: INT32
  use, intrinsic :: iso_fortran_env, only: REAL32
  implicit none

contains

  @test
  subroutine test_assign_to_logical_scalar()
    logical :: found

    found = Configuration(scalar=.true.) ! needs overloaded assignment
    @assert_that(found, is(True()))
    
  end subroutine test_assign_to_logical_scalar

  @test
  subroutine test_assign_to_integer_scalar()
    integer :: found

    found = Configuration(scalar=1) ! needs overloaded assignment
    @assert_that(found,is(equal_to(1)))
    
    found = Configuration(scalar=2) ! needs overloaded assignment
    @assert_that(found,is(equal_to(2)))

  end subroutine test_assign_to_integer_scalar

  @test
  subroutine test_assign_to_real_scalar()
    real :: found
    real :: expected = 1.23

    found = Configuration(scalar=expected) ! needs overloaded assignment
    @assert_that(found,is(equal_to(expected)))
    
  end subroutine test_assign_to_real_scalar
  
  @test
  ! Type-mismatch
  subroutine test_assign_to_integer_fail_set_default()
    integer :: found
    real :: expected = 1.23

    found = Configuration(scalar=expected)
    @assert_that(found,is(equal_to(-huge(1_INT32))))

  end subroutine test_assign_to_integer_fail_set_default

  @test
  subroutine test_assign_to_string_scalar()
    type(AllocatableConfiguration) :: c
    character(:), allocatable :: found
    character(*), parameter :: expected = 'dog'

    c = Configuration(scalar=expected)
    found = c ! overloaded assignment
  end subroutine test_assign_to_string_scalar


  @test
  subroutine test_assign_to_logical_array()
    logical, allocatable :: found(:)

    print*,__FILE__,__LINE__
    found = Configuration(array=[.true.,.false.]) ! needs overloaded assignment
    print*,__FILE__,__LINE__
    @assert_that(found,is(equal_to([.true.,.false.])))
    print*,__FILE__,__LINE__
    
  end subroutine test_assign_to_logical_array

  @test
  subroutine test_assign_to_logical_array_from_unlimited_vector()
    logical, allocatable :: found(:)
    type (UnlimitedVector) :: v

    call v%push_back(.false.)
    call v%push_back(.true.)
    call v%push_back(.false.)
    
    found = Configuration(scalar=v)
    @assert_that(found,is(equal_to([.false.,.true.,.false.])))
    
  end subroutine test_assign_to_logical_array_from_unlimited_vector

  @test
  subroutine test_assign_to_logical_array_fail()
    logical, allocatable :: found(:)
    type (UnlimitedVector) :: v

    ! type mismatch
    found = Configuration(array=[1.,3.])
    @assert_that(found, is(empty_array()))
    
    ! category mismatch
    deallocate(found)
    found = Configuration(scalar=1)
    @assert_that(found, is(empty_array()))

    ! mixed types in unlimited
    call v%push_back(3)
    call v%push_back(.true.)
    deallocate(found)
    found = Configuration(scalar=v)
    @assert_that(found, is(empty_array()))
    
  end subroutine test_assign_to_logical_array_fail
  
  
  @test
  subroutine test_assign_to_integer_array()
    integer, allocatable :: found(:)

    found = Configuration(array=[1,3]) ! needs overloaded assignment
    @assert_that(found,is(equal_to([1,3])))
    
  end subroutine test_assign_to_integer_array

  @test
  subroutine test_assign_to_integer_array_from_unlimited_vector()
    integer, allocatable :: found(:)
    type (UnlimitedVector) :: v

    print*,__FILE__,__LINE__
    call v%push_back(3)
    call v%push_back(2)
    call v%push_back(1)
    print*,__FILE__,__LINE__
    
    found = Configuration(scalar=v)
    print*,__FILE__,__LINE__
    @assert_that(found,is(equal_to([3,2,1])))
    print*,__FILE__,__LINE__
    
  end subroutine test_assign_to_integer_array_from_unlimited_vector

  @test
  subroutine test_assign_to_integer_array_fail()
    integer, allocatable :: found(:)
    type (UnlimitedVector) :: v

    ! type mismatch
    found = Configuration(array=[1.,3.])
    @assert_that(found, is(empty_array()))
    
    ! category mismatch
    deallocate(found)
    found = Configuration(scalar=1)
    @assert_that(found, is(empty_array()))

    ! mixed types in unlimited
    call v%push_back(3)
    call v%push_back(2.)
    deallocate(found)
    found = Configuration(scalar=v)
    @assert_that(found, is(empty_array()))
    
  end subroutine test_assign_to_integer_array_fail
  
  
  @test
  subroutine test_assign_to_real_array()
    real, allocatable :: found(:)

    found = Configuration(array=[1.,3.]) ! needs overloaded assignment
    @assert_that(found,is(equal_to([1.,3.])))
    
  end subroutine test_assign_to_real_array

  @test
  subroutine test_assign_to_real_array_from_unlimited_vector()
    real, allocatable :: found(:)
    type (UnlimitedVector) :: v

    print*,__FILE__,__LINE__
    call v%push_back(3.)
    call v%push_back(2.)
    call v%push_back(1.)
    
    print*,__FILE__,__LINE__
    found = Configuration(scalar=v)
    print*,__FILE__,__LINE__
    @assert_that(found,is(equal_to([3.,2.,1.])))
    print*,__FILE__,__LINE__
    
  end subroutine test_assign_to_real_array_from_unlimited_vector

  @test
  subroutine test_assign_to_real_array_fail()
    real, allocatable :: found(:)

    ! type mismatch
    found = Configuration(array=[1,3])
    @assert_that(found, is(empty_array()))
    
    ! category mismatch
    deallocate(found)
    found = Configuration(scalar=1)
    @assert_that(found, is(empty_array()))

  end subroutine test_assign_to_real_array_fail
  

  @test
  subroutine test_assign_to_string_array()
    character(:), allocatable :: found(:)

    found = Configuration(array=[character(4) :: 'cat', 'food'])
    @assert_that(found,is(equal_to(['cat ','food'])))
    
  end subroutine test_assign_to_string_array

  ! Support varying length strings with StringVector
  @test
  subroutine test_assign_to_string_vector()
    use gFTL_StringVector
    type (StringVector) :: found
    type (UnlimitedVector) :: expected
    integer :: n

 
    ! This way pads ...
    found = Configuration(array=[character(4) :: 'cat', 'food'])
    @assert_that(int(found%size()), is(equal_to(2)))
    @assert_that(found%at(1), is(equal_to('cat ')))
    @assert_that(found%at(2), is(equal_to('food')))
    print*,__FILE__,__LINE__

    ! This way does not ...
    call expected%push_back(String('cat'))
    call expected%push_back(String('food'))

    found = Configuration(scalar=expected)
    print*,__FILE__,__LINE__
    @assert_that(int(found%size()), is(equal_to(2)))
    print*,__FILE__,__LINE__
    @assert_that(found%at(1), is(equal_to('cat')))
    print*,__FILE__,__LINE__
    @assert_that(found%at(2), is(equal_to('food')))
    print*,__FILE__,__LINE__
    
  end subroutine test_assign_to_string_vector

  @test
  subroutine test_assign_to_string_array_from_unlimited_vector()
    character(:), allocatable :: found(:)
    type (UnlimitedVector) :: v

    call v%push_back(String('cat'))
    call v%push_back(String('food'))
    call v%push_back(String(''))
    
    found = Configuration(v)
    @assert_that(found,is(equal_to(['cat ','food','    '])))
    
  end subroutine test_assign_to_string_array_from_unlimited_vector

  @test
  subroutine test_assign_to_string_array_fail()
    character(:), allocatable :: found(:)
    type (UnlimitedVector) :: v

    ! type mismatch
    found = Configuration(array=[1,3])
    @assert_that(found, is(empty_array()))
    
    ! partial mismatch
    call v%push_back('a')
    call v%push_back(1)
    found = Configuration(scalar=v)
    @assert_that(found, is(empty_array()))
    
    ! category mismatch
    deallocate(found)
    found = Configuration(scalar=1)
    @assert_that(found, is(empty_array()))

  end subroutine test_assign_to_string_array_fail

  @test
  subroutine test_at_key_not_a_map()
    type(AllocatableConfiguration) :: c
    type(PointerConfiguration) :: sub

    print*,__FILE__,__LINE__
    c = Configuration(scalar=1)
    print*,__FILE__,__LINE__
    sub = c%at('non-existent-key') ! should "fail"
    print*,__FILE__,__LINE__
    @assert_that(sub%is_none(), is(true()))
    print*,__FILE__,__LINE__
    
  end subroutine test_at_key_not_a_map

  @test
  subroutine test_at_key_not_a_key()
    type(AllocatableConfiguration) :: c
    type(PointerConfiguration) :: sub
    type(StringUnlimitedMap) :: map

    call map%insert('a',1)
    call map%insert('b',.true.)
    c = Configuration(scalar=map)
    sub = c%at('non-existent-key') ! should "fail"
    @assert_that(sub%is_none(), is(true()))
    
  end subroutine test_at_key_not_a_key

  @test
  subroutine test_at_key_integer()
    type(AllocatableConfiguration) :: c
    type(StringUnlimitedMap) :: map
    integer :: found
    
    call map%insert('a',1)
    call map%insert('b',2)
    c = Configuration(map)
    found = c%at('b')
    @assert_that(found,is(equal_to(2)))
  end subroutine test_at_key_integer

  @test
  subroutine test_at_key_logical()
    type(AllocatableConfiguration) :: c
    type(StringUnlimitedMap) :: map
    logical :: found
    
    call map%insert('a',1)
    call map%insert('b',.false.)
    c = Configuration(map)
    found = c%at('b')
    @assert_that(found,is(false()))
  end subroutine test_at_key_logical

  @test
  subroutine test_at_key_map()
    type(AllocatableConfiguration) :: c
    type(StringUnlimitedMap) :: map1, map2
    type(StringUnlimitedMap) :: found_map

    call map1%insert('triangle',3)
    call map1%insert('quadrilateral',4)

    call map2%insert('a',1)
    call map2%insert('b',map1)

    c = Configuration(map2)
    found_map = c%at('b')
    @assert_that(found_map%at('triangle'),is(equal_to(3)))

  end subroutine test_at_key_map

  @test
  subroutine test_at_index_not_a_vector()
    type(AllocatableConfiguration) :: c
    type(PointerConfiguration) :: sub

    c = Configuration(scalar=1)
    sub = c%at(5) ! should "fail"
    @assert_that(sub%is_none(), is(true()))
    
  end subroutine test_at_index_not_a_vector
  
  !@test
  subroutine test_at_index_out_of_range()
    type(AllocatableConfiguration) :: c
    type(PointerConfiguration) :: sub
    type(UnlimitedVector) :: v

    call v%push_back(1)
    call v%push_back(7.)
    c = Configuration(scalar=v)

    sub = c%at(5) ! should "fail"
    @assert_that(sub%is_none(), is(true()))
    
  end subroutine test_at_index_out_of_range
  
  @test
  subroutine test_at_indexb()
    type(AllocatableConfiguration), target :: c
    type(UnlimitedVector) :: vector
    logical :: found_logical
    integer :: found_integer
    real :: found_real
    character(:), allocatable :: found_string
    
    call vector%push_back(.true.)
    call vector%push_back(1)
    call vector%push_back(1.234)
    call vector%push_back(String('foo'))
    c = Configuration(vector)

    print*,__FILE__,__LINE__
!!$    found_logical = c%at(1)
    call c%get(found_logical, index=1)
    @assert_that(found_logical,is(true()))
    print*,__FILE__,__LINE__

    found_integer = c%at(2)
!!$    @assert_that(found_integer,is(equal_to(1)))
!!$    print*,__FILE__,__LINE__
!!$
    found_real = c%at(3)
!!$    @assert_that(found_real,is(equal_to(1.234)))
!!$    print*,__FILE__,__LINE__
!!$
!!$    found_string = c%at(4)
!!$    @assert_that(found_string,is(equal_to('foo')))

  end subroutine test_at_indexb

  !@test
  subroutine test_at_index_map()
    type(AllocatableConfiguration) :: c
    type(StringUnlimitedMap) :: map
    type(UnlimitedVector) :: v
    type(StringUnlimitedMap) :: found_map

    call map%insert('triangle',3)
    call map%insert('quadrilateral',4)

    call v%push_back(1)
    call v%push_back(map)
    call v%push_back(2.)

    c = Configuration(v)
    found_map = c%at(2)
    @assert_that(found_map%at('triangle'),is(equal_to(3)))
    @assert_that(found_map%at('quadrilateral'),is(equal_to(4)))

  end subroutine test_at_index_map

end module Test_Configuration_casting
