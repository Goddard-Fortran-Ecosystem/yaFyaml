module Test_YAML_Parser
  use funit
  use MockFile_mod
  use yafyaml
  implicit none

contains

  @test
  subroutine test_interpret_token_logical_false()
    use gFTL_StringVector
    type (YAML_Parser) :: p
    type(StringVector) :: false_tokens
    type(StringVectorIterator) :: iter
    character(:), allocatable :: token
    
    call false_tokens%push_back('n')
    call false_tokens%push_back('N')
    call false_tokens%push_back('no')
    call false_tokens%push_back('No')
    call false_tokens%push_back('NO')
    call false_tokens%push_back('false')
    call false_tokens%push_back('False')
    call false_tokens%push_back('FALSE')
    call false_tokens%push_back('off')
    call false_tokens%push_back('Off')
    call false_tokens%push_back('OFF')

    iter = false_tokens%begin()
    do while (iter /= false_tokens%end())
       token = trim(iter%get())
       @assert_that('tried with '//token, p%interpret(token), is(false()))
       call iter%next()
    end do
  end subroutine test_interpret_token_logical_false

  @test
  subroutine test_interpret_token_logical_true()
    use gFTL_StringVector
    type (YAML_Parser) :: p
    type(StringVector) :: true_tokens
    type(StringVectorIterator) :: iter
    character(:), allocatable :: token

    call true_tokens%push_back('y')
    call true_tokens%push_back('Y')
    call true_tokens%push_back('yes')
    call true_tokens%push_back('Yes')
    call true_tokens%push_back('YES')
    call true_tokens%push_back('true')
    call true_tokens%push_back('True')
    call true_tokens%push_back('TRUE')
    call true_tokens%push_back('on')
    call true_tokens%push_back('On')
    call true_tokens%push_back('ON')

    iter = true_tokens%begin()
    do while (iter /= true_tokens%end())
       token = trim(iter%get())
       @assert_that('Tried with <"'//token//'">', p%interpret(token), is(true()))
       call iter%next()
    end do

  end subroutine test_interpret_token_logical_true

  @test
  subroutine test_interpret_token_integer()
    use gFTL_StringIntegerMap
    type (YAML_Parser) :: p
    type(StringIntegerMap) :: int_tokens
    type(StringIntegerMapIterator) :: iter
    character(:), allocatable :: token

    call int_tokens%insert('0',0)
    call int_tokens%insert('1',1)
    call int_tokens%insert('-1',-1)
    call int_tokens%insert('1234',1234)

    iter = int_tokens%begin()
    do while (iter /= int_tokens%end())
       token = trim(iter%key())
       @assert_that('Tried with <"'//token//'">', p%interpret(token), is(equal_to(iter%value())))
       call iter%next()
    end do

  end subroutine test_interpret_token_integer

  @test
  subroutine test_interpret_token_real()
    use gFTL_StringReal32Map
    type (YAML_Parser) :: p
    type(StringReal32Map) :: real_tokens
    type(StringReal32MapIterator) :: iter
    character(:), allocatable :: token

    call real_tokens%insert('0.',0.)
    call real_tokens%insert('1.',1.)
    call real_tokens%insert('-1.',-1.)
    call real_tokens%insert('1.234',1.234)

    iter = real_tokens%begin()
    do while (iter /= real_tokens%end())
       token = trim(iter%key())
       @assert_that('Tried with <"'//token//'">', p%interpret(token), is(equal_to(iter%value())))
       call iter%next()
    end do

  end subroutine test_interpret_token_real

  @test
  subroutine test_interpret_token_string()
    use gFTL_StringVector
    type (YAML_Parser) :: p
    type(StringVector) :: strings
    type(StringVectorIterator) :: iter
    character(:), allocatable :: token

    call strings%push_back('a')
    call strings%push_back('"on"')
    call strings%push_back("'off'")
    call strings%push_back(' ')
    call strings%push_back('bike')
    ! variant capitalizations are strings, not bools
    call strings%push_back('fAlse')

    iter = strings%begin()
    do while (iter /= strings%end())
       token = trim(iter%get())
       @assert_that('Tried with <"'//token//'">', p%interpret(token), is(equal_to(token)))
       call iter%next()
    end do
    
  end subroutine test_interpret_token_string
  

  @test
  subroutine test_parse_single_node_scalar_int()
    type(YAML_Parser) :: p
    type(Configuration) :: config

    type(MockFile) :: f
    character(:), allocatable :: line
    integer :: i

    f = MockFile()
    call f%write_line('5')
    call f%rewind

    p = YAML_Parser()
    call p%load(f, config)

    i = config
    @assert_that(i,is(equal_to(5)))
    call f%close(delete=.true.)
    
  end subroutine test_parse_single_node_scalar_int

  @test
  subroutine test_parse_single_node_scalar_int_b()
    type(YAML_Parser) :: p
    type(Configuration) :: config

    type(MockFile) :: f
    character(:), allocatable :: line
    integer :: i

    f = MockFile()
    call f%write_line('3')
    call f%rewind

    p = YAML_Parser()
    call p%load(f, config)

    i = config
    @assert_that(i,is(equal_to(3)))
    call f%close(delete=.true.)
    
  end subroutine test_parse_single_node_scalar_int_b

  ! YAML files can start with '---', which is ignored
  @test
  subroutine test_ignore_triple_hyphen()
    type(YAML_Parser) :: p
    type(Configuration) :: config

    type(MockFile) :: f
    character(:), allocatable :: line
    integer :: i

    f = MockFile()
    call f%write_line('---')
    call f%write_line('3')
    call f%rewind

    p = YAML_Parser()
    call p%load(f, config)

    i = config
    @assert_that(i,is(equal_to(3)))
    call f%close(delete=.true.)
    
  end subroutine test_ignore_triple_hyphen

  @test
  subroutine test_parse_single_node_logical()
    type(YAML_Parser) :: p
    type(Configuration) :: config

    type(MockFile) :: f
    character(:), allocatable :: line
    logical :: flag

    f = MockFile()
    call f%write_line('true')
    call f%rewind

    p = YAML_Parser()
    call p%load(f, config)

    flag = config

    @assert_that(flag,is(true()))
    call f%close(delete=.true.)
  end subroutine test_parse_single_node_logical
  
  @test
  subroutine test_parse_single_node_string()
    type(YAML_Parser) :: p
    type(Configuration) :: config

    type(MockFile) :: f
    character(:), allocatable :: line
    character(:), allocatable :: item

    f = MockFile()
    call f%write_line('bike')
    call f%rewind

    p = YAML_Parser()
    call p%load(f, config)

    item = config

    @assert_that(item,is(equal_to('bike')))
    call f%close(delete=.true.)
  end subroutine test_parse_single_node_string
  
  @test
  subroutine test_parse_single_entry_map()
    type(YAML_Parser) :: p
    type(Configuration) :: config

    type (Configuration) :: c
    integer :: value

    type(MockFile) :: f
    character(:), allocatable :: line
    character(:), allocatable :: item

    f = MockFile()
    call f%write_line('a: 1')
    call f%rewind

    p = YAML_Parser()
    call p%load(f, config)

    c = config
    value = c%at(key='a')

    @assert_that(value, is(equal_to(1)))
    call f%close(delete=.true.)
  end subroutine test_parse_single_entry_map
  
end module Test_YAML_Parser
